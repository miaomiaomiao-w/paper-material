# -*- coding: utf-8 -*-
"""KG for RAG_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J3_1uLTTfFM_1rD2L2N6JJsaCBToo99R

# Question Shuffle
"""

import pandas as pd

import sys
print(sys.executable)

def shuffle_excel_rows(input_file, output_file):
    df = pd.read_excel(input_file)
    shuffled_df = df.sample(frac=1).reset_index(drop=True)
    shuffled_df.to_excel(output_file, index=False)

# 使用函数
shuffle_excel_rows('问题生成.xlsx', '问题生成_Shuffle.xlsx')

"""# Query"""

from dotenv import load_dotenv
import os
import sys
import io

import textwrap

# Langchain
from langchain_community.graphs import Neo4jGraph
from langchain_community.vectorstores import Neo4jVector
from langchain_openai import OpenAIEmbeddings
from langchain.chains import RetrievalQAWithSourcesChain
from langchain.prompts.prompt import PromptTemplate
from langchain.chains import GraphCypherQAChain
from langchain_openai import ChatOpenAI
import re
import openpyxl

import pandas as pd

# Warning control
import warnings
warnings.filterwarnings("ignore")

# Load from environment
NEO4J_URI = 'neo4j://localhost:7687'
NEO4J_USERNAME = 'neo4j'
NEO4J_PASSWORD = 'your username'
NEO4J_DATABASE = os.getenv('NEO4J_DATABASE') or 'neo4j'

kg = Neo4jGraph(
    url=NEO4J_URI, username=NEO4J_USERNAME, password=NEO4J_PASSWORD, database=NEO4J_DATABASE
)

SCHEMA = kg.schema
pattern = r'(\{.*?\})'
new_schema = re.sub(pattern, lambda x: '{{{}}}'.format(x.group(1)), SCHEMA)

def Prompt_Template_func_zero(new_schema, question):
    CYPHER_GENERATION_TEMPLATE = f"""
    Task:Generate Cypher statement to query the Shan Jing (《山经》) graph database.
    Instructions: Use only the provided relationship types and properties in the schema. Do not use any other relationship types or properties that are not provided.
    Schema:
    {new_schema}

    Note:
    Do not include any explanations or apologies in your responses.
    Do not respond to any questions that might ask anything else than for you to construct a Cypher statement.
    Do not include any text except the generated Cypher statement.
    For the final output, you should include all the entities or relationships you have got.

    The question is:
    {question}
    """

    return CYPHER_GENERATION_TEMPLATE

# 定义Prompt
def Prompt_Template_func_one(new_schema, question):
    CYPHER_GENERATION_TEMPLATE = f"""
    Task:Generate Cypher statement to query the Shan Jing (《山经》) graph database.
    Instructions: Use only the provided relationship types and properties in the schema. Do not use any other relationship types or properties that are not provided.
    Schema:
    {new_schema}

    Note:
    Do not include any explanations or apologies in your responses.
    Do not respond to any questions that might ask anything else than for you to construct a Cypher statement.
    Do not include any text except the generated Cypher statement.
    For the final output, you should include all the entities or relationships you have got.

    Examples: Here are a few examples of generated Cypher statements for particular questions:

    # 请介绍《山经》中的堂庭之山？
    # 山经中对堂庭之山有何特别的描述？
    # 你对堂庭之山在山经中的记载有何了解？
    MATCH(p)-[r]-(q)
    WHERE p.name='堂庭之山'
    RETURN p,r,q

    # 飞鱼在山经中有何记载？
    # 山经中有关飞鱼的内容是？
    MATCH(p)-[r]-(q)
    WHERE p.name='飞鱼'
    RETURN p,r,q

    # 山经中描述了鳣怎样的特征？
    # 山经中的鳣生活习性如何？
    # 山经中的鳣有怎样的特征？
    # 山经中的鳣是如何被描绘的？
    MATCH (a)
    WHERE a.name='鳣'
    RETURN properties(a) as propertiesExist

    # 山经中是否描述了鳣的特征？
    MATCH (a)
    WHERE a.name='鳣' AND size(keys(a)) > 1
    RETURN a

    # 山经中的狌狌是指什么生物？
    # 山经中记录的狌狌是什么？
    MATCH (a)
    WHERE a.name='狌狌'
    RETURN labels(a) AS categor,a

    # 山经中的矿类有哪些？
    MATCH (n:`矿类`)
    RETURN n

    # 山经中的英水在哪些章节出现？
    # 山经中有关英水的信息在哪里？
    # 山经中有关英水的记录在哪里？
    MATCH (p:`经名`)-[r:`之`]->(chapter:`章节`)-[s:`记录`]->(mountain:`山类`)-[t*0..1]->(q)
    WHERE q.name='英水'
    RETURN chapter.name as chapterName
    UNION
    MATCH (p:`经名`)-[r:`之`]->(chapter:`章节`)-[s:`记录`]->(mountain:`山类`)<-[t*0..1]-(m:`水类`)-[u*0..1]->(q)
    WHERE q.name='英水'
    RETURN chapter.name as chapterName

    # 皇人之山和哪座山相邻？
    # 皇人之山在山经中的位置是怎样的？
    MATCH(p:`山类`)-[r:`东`|`东南`|`西`|`西南`|`西北`|`北`|`东北`|`南`|`临于`|`踆于`|`东望`|`东南`|`西临`|`北望`|`望`|`出于`|`西南`|`西北`|`南望`|`西望`|`临彼`|`北`|`东北`|`南`|`北临`|`南临`]->(q)
    WHERE p.name='皇人之山'
    RETURN p,r,q
    UNION
    MATCH(p:`山类`)<-[r:`东`|`东南`|`西`|`西南`|`西北`|`北`|`东北`|`南`|`临于`|`踆于`|`东望`|`东南`|`西临`|`北望`|`望`|`出于`|`西南`|`西北`|`南望`|`西望`|`临彼`|`北`|`东北`|`南`|`北临`|`南临`]-(q)
    WHERE p.name='皇人之山'
    RETURN p,r,q

    # 尧光之山与其相邻的山相隔多远？
    MATCH (p)-[r:`东`|`东南`|`西`|`西南`|`西北`|`北`|`东北`|`南`|`临于`|`踆于`|`东望`|`东南`|`西临`|`北望`|`望`|`出于`|`西南`|`西北`|`南望`|`西望`|`临彼`|`北`|`东北`|`南`|`北临`|`南临`]-(q:`山类`)
    WHERE p.name='尧光之山'
    RETURN p.name, r.distance, q.name

    # 赤铜在山经中分布在哪些地方？
    # 赤铜在山经中常见吗？
    MATCH(p)-[r:`有`|`多`]-(q)
    WHERE q.name = '赤铜'
    RETURN p,r,q

    # 旄水的发源地是哪里？
    MATCH (p:`山类`)<-[r:`出于`]-(q:`水类`)
    WHERE q.name='旄水'
    RETURN p.name as sourceName

    # 弱水是哪条河的支流？
    # 若水流入了哪条河？
    MATCH (p:`水类`)-[r:`东流`|`东南流`|`北流`|`南流`|`西流`|`东北流`|`西南流`|`西北流`|`入流`]-(q:`水类`)
    WHERE p.name='弱水'
    RETURN p,r,q

    # 哪些山的水流向了黑水？
    MATCH L=(p:`山类`)<-[r]-(q:`水类`)-[s:`东流`|`东南流`|`北流`|`南流`|`西流`|`东北流`|`西南流`|`西北流`|`入流`]->(m:`水类`)
    WHERE m.name = '黑水'
    RETURN L

    The question is:
    {question}
    """

    return CYPHER_GENERATION_TEMPLATE

"""# Integration
【Langchain-Neo4j】
https://python.langchain.com/v0.1/docs/integrations/graphs/neo4j_cypher/#use-separate-llms-for-cypher-and-answer-generation  

【Langchain的OpenAI和ChatOpenAI】
https://python.langchain.com/v0.1/docs/modules/agents/agent_types/openai_functions_agent/

QW README:
https://github.com/QwenLM/Qwen/blob/main/README_CN.md
"""

def extract_between(text, start, end):
    """Extract text between two markers."""
    return text.split(start)[-1].split(end)[0].strip()

def clean_output(text):
    return re.sub(r'\x1b\[[0-9;]*m', '', text)

def save_to_excel(data, output_file):
    df = pd.DataFrame(data, columns=["Num", "Entity", "Question", "Generated Cypher", "Full Context", "Finished Output"])
    df.to_excel(output_file, index=False)

def Shanjing_QA(new_schema, question, num, entity):
    original_stdout = sys.stdout
    sys.stdout = io.StringIO()

    CYPHER_GENERATION_TEMPLATE = Prompt_Template_func(new_schema, question)
    CYPHER_GENERATION_PROMPT = PromptTemplate(
        input_variables=["schema", "question"],
        template=CYPHER_GENERATION_TEMPLATE
    )
    cypherChain = GraphCypherQAChain.from_llm(
        ChatOpenAI(
            # QW
            #model = 'qwen-max',
            #openai_api_key="your api_key",
            #openai_api_base="https://dashscope.aliyuncs.com/compatible-mode/v1",
            # GPT
            #model = 'gpt-4o',
            #openai_api_base = "https://apikeyplus.com/v1", # 换成代理url,
            #openai_api_key = "your api_key" ,
            #GLM
            model = 'glm-4-plus',
            openai_api_key = "your api_key",
            openai_api_base = "https://open.bigmodel.cn/api/paas/v4/",

            temperature=0,
            max_tokens=1000,
        ),
        graph=kg,
        verbose=True,
        top_k=1000,
        cypher_prompt=CYPHER_GENERATION_PROMPT,
        allow_dangerous_requests=True,
    )
    try:
        response = cypherChain.run(question)
    except ValueError as e:
        if 'Generated Cypher Statement is not valid' in str(e):
            print("Invalid Cypher Statement")
            response = None
        else:
            raise e
        # 获取输出内容并重置stdout
    output = sys.stdout.getvalue()
    sys.stdout = original_stdout

    # 解析输出内容
    generated_cypher = extract_between(output, "Generated Cypher:", "Full Context:")
    generated_cypher = clean_output(generated_cypher)
    full_context = extract_between(output, "Full Context:", "> Finished chain.")
    full_context = clean_output(full_context)
    finished_output = response

    return num, entity, question, generated_cypher, full_context, finished_output

file_path = '问题生成_Shuffle.xlsx'
df = pd.read_excel(file_path)
content = df.loc[:2, ['Question', 'Num ID', 'Entity']]

results = []
for index, row in content.iterrows():
        question = row['Question']
        num = row['Num ID']
        entity = row['Entity']
        result = Shanjing_QA(new_schema, question, num, entity)
        print('finished row' + str(index))
        results.append(result)

print(results)
#save_to_excel(results, 'output_GPT_zero shot.xlsx')

save_to_excel(results, 'output_GLMplus_zero shot.xlsx')